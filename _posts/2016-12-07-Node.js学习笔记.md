---
layout: post
title: Nodejs学习笔记
description: 主要记录下自己学习Node.js中比较重要和容易混淆的知识点，仅供自己review复习使用。
keywords: Nodejs
categories : [Nodejs]
tags : [Nodejs]
---

作者：李阳

-------------------
笔者背景：对python和java了解并有一定的经验，在服务端开发中拥有比较多的项目经验，对于JavaScript处于初学阶段，曾短暂在公司项目既有框架下使用过
angularJs完成部分业务逻辑，Node.js纯新手。本篇博文只是用来记录我学习Node.js过程中遇到的某些知识点或难点，供自己review复习使用。
并不一定具有参考性和保证完全正确。

我暂时使用的编辑器为sublime text3，可以参考博文[mac下安装sublime text3 nodeJs环境](http://blog.csdn.net/phil_young/article/details/50950206)

## 服务端 javaScript
Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境运行JavaScript代码）

要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，
它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。

因此，Node.js事实上既是一个运行时环境，同时又是一个库。

- 实现http服务器

  Node.js需要实现一个http服务器，比如：

	var http = require("http");
	http.createServer(function(request, response) {
	response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello World");
    response.end();
    }).listen(8080);

  调用http模块的createServer方法监听了8080端口。其中向该方法传递了一个匿名函数。
  request和response均为对象，request发起请求和response相应请求。

- 事件驱动和回调
  
  NodeJs是基于事件驱动的（事件轮询），我们创建了服务器，并且向创建它的方法传递了一个函数，无论何时我们的服务器收到一个请求，
  这个函数就会被调用。所以这个函数是预先定义的函数还是匿名函数就无关紧要了。这就是回调，给一个方法传递了一个函数，这个方法在有相应时间发生时调用这个
  函数来进行回调。
  
## JavaScript与Node中的js
  JavaScript类型包括简单类型和复杂类型，访问基本类型访问的是值，访问复杂类型，访问的是对值得引用。例如`var a = ["test"];var b = a`;修改b即为修改a
  
  typeOf不会把null识别为null，例如`typeof null == 'object' `为true。[]也为object。
  
  JavaScript函数中有个属性为参数数量`var a = function(a,b,c);a.lenth == 3;`一些流行的Nodejs框架根据此属性来根据不同参数提供不同的功能。
  
  **自执行函数**
  我觉得js里比较有意思的一个地方，写法通常是(function(){...}())或者(function(){..}}()。自执行函数对声明私有变量是很有用的，可以让私有变量不被其他代码访问，起到私有作用域的效果。
  函数表达式后加括号，当js引擎执行到此处时能立即调用函数，但是函数声明后加括号随不报错，但也不会调用。自执行函数括号里包裹的其实就是一个函数表达式。
  
  **v8引擎JS**
  - Array.isArray检查是否为数组。  
  - for(var i in a)可以对键进行迭代。
  - 遍历数组forEach()
  - 改变数组可以用map,例如[1,2,3].map(function(v){return v*2});
  
  
  **Node**中的js
  Node.js除了提供和浏览器一样的语言之外，还在语言基础上提供构建强大网路应用所需的api。
  
##阻塞与非阻塞io
  
在Node中需要对回调函数如何修改当前内存中的变量（状态）特别小心，通俗的讲，还要特别注意对错误的处理是否会潜在的修改这些状态，从而导致了整个进程不可用。
Node采取了一个长期运行的进程，所以每次调用函数的时候都可能会修改状态。Node使用的是事件轮询，从本质上来说，Node会先注册事件，随后不停地询问内核这些事件是否已经分发。
当事件分发时，对应的回调函数就会被触发，然后继续执行下去，如果没有事件触发，则继续执行其他代码，直到有新事件时，再去执行对应的回调函数。
例如setTime（function(console.log('world'),5000） 相当于注册了一个事件，其后的事件如console等会立即执行。
node的并发也采用相同的机制。
  
- Node是单线程的
 
**异常处理**
可以添加uncatchException处理器，利用回调函数来处理异常。例如：
      
    process.on('uncatchException',function(err){
      console.log(err);
      process.exit(1);
    });
也可以和其他语言一样，使用try，catch。而且当引入事件轮询后，要捕获一个未来执行的函数所跑出的错误是不可能的，所以会跑出未捕获的异常，并且catch块后的代码永远
不会执行。
 
 
  
  
 
  
  
  