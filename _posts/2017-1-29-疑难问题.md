---
layout: post
title: java复习问题总结纲要
description: 近期对java的相关知识进行了复习。将各种资料总结成文，方便自己回顾浏览。
keywords: Java
categories : [Java]
tags : [Java]
---

作者：李阳

-------------------
#java复习问题总结

1.	什么时候用assert？

2.	collection和collections的区别。

3.	线程同步的方法。

4.  简述synchronized 和 java.util.concurrent.locks.Lock 的异同

5.	单例模式的几种写法。

6.	同步异步，阻塞和非阻塞。

7.	反射

8.	java nio基本概念

9.	类加载器

10. java注解

11.	gc，full gc，内存泄漏。垃圾回收的方法。gc种类

12.	ThreadLocal

13.	statement，prepareStatement

14.	this,super.本质上this是指向本对象的指针， super是一个关键字

15.	java 方法区：与堆一样,是线程共享的区域。方法区中存储：被虚拟机加载的类信息，常量，静态变量，编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。

16.	java 栈和堆。基本类型和引用类型。基本类型储存在栈，引用类型存储在堆中。栈通常比堆小，也不会在多个线程之间共享，而堆被整个jvm共享。

17.	a=a+b和a+=b的区别：	
+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。

18.	从java7开始，我们可以在switch case中使用字符串，但这仅仅是个语法糖。内部实现在switch中使用字符串的hash code。

19.	编译期常量是什么（public static final），有什么风险。

20.	Hashset的内部是通过hashmap实现的。

21.	oop中的关联，组合和聚合

22.	jdk1.7和jdk1.

23.	java语言的鲁棒性

24.	子类可以继承父类的静态方法，但是不能覆盖。因为静态方法在编译时就已经确定了，不能多态，也不能运行时绑定。

#jvm
1.	栈是运行时单位，堆是存储的单位，一个线程就有一个线程栈与之对应，而堆是共享的。堆中存的是对象，而栈中存的是基本数据类型和堆中对象的引用（4byte）。
	在java中，Main函数就是栈的起点，也是程序的起点。-Xss设置栈的大小。

2.	一个空Object大小为8byte，且对象的大小为8的整数倍。（栈上还有4byte的引用大小）

3.	引用分为强引用，弱引用，软引用和虚引用。弱引用和软引用通常用于缓存。

4.	垃圾回收策略：引用计数（无法处理循环引用的问题），标记-清除（需要暂停应用，同事产生碎片），复制（不会有碎片，但需两倍内存空间），标记整理（最优，将存活对象压缩到堆中一块）。

5.	分代的垃圾回收策略是基于这样一个事实：不同的对象的生命周期是不一样的。虚拟机划分为三个代：年轻代（通常一个Eden区，两个Survivor区），年老代，持久代（用于存放
	静态文件）。

6.	gc有两种：Scavenge GC（Eden申请空间失败时触发，频繁进行）和full GC（年老代被写满，持久代写满，System.gc()显示调用）。

7.	串行收集器（-XX:+UseSerialGC），并行收集器（XX:+UseParallelGC.）和并发收集器（-XX:+UseConcMarkSweepGC，垃圾回收只占用很少时间，保证大部分工作都并行执行，适用与对响应时间要求比较高的中、大规模应用）

8.	-Xmx：jvm最大可用内存 -Xnm年轻代大小，-Xss每个线程的栈大小，-XX:NewRatio，-XX:SurvivorRatio，-XX:MaxPermSize，-XX:MaxTenuringThreshold=0（设置垃圾最大年龄。如果设置为0，则不经过survivor直接进入年老代，值越大，在survivor中复制次数越多，在年轻代存活时间越长）。
-XX:+UseCMSCompactAtFullCollection:使用并发收集器时，开启对年老代的压缩

9.	内存泄漏检查：可能引起年老代堆空间被占满（内存泄漏），持久代被占满（大量反射，热发布环境中），堆栈溢出（递归没返回，或循环调用），线程池堆满，系统内存被占满（无资源创建线程）。
oom分为两种，java heap size和PermGen space。

10.	jvm分为四个部分：类加载器（Class loader），执行引擎（Execution Engine），本地接口（Native Interface），运行数据区（Runtime data area）

11.	方法区：是线程共享的区域。方法区中存储：被虚拟机加载的类信息，常量，静态变量，编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。
在jvm中，堆和方法去是共享的，其他都是私有的。

12.	每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列，就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程，当一个被线程被唤醒(notify)后，才会进入到就绪队列，等待cpu的调度。synchronized既保证了多线程的并发有序性，又保证了多线程的内存可见性。

13.	volatile值保证可见性，不保证有序性。任何被修饰的变量，都不拷贝副本到工作内存，任何修改都及时写在主存。volatile适合直接赋值的场景。

14.	gc收集规则：一、通常情况下，对象在eden中分配。当eden无法分配时，触发一次Minor GC。二、配置了PretenureSizeThreshold的情况下，对象大于设置值将直接在老年代分配。
三、在eden经过GC后存活，并且survivor能容纳的对象，将移动到survivor空间内，如果对象在survivor 中继续熬过若干次回收(默认为15次)将会被移动到老年代中。回收次数由MaxTenuringThreshold设置。四、如果在survivor空间中相同年龄所有对象大小的累计值大于survivor空间的一半，大于或等于个年龄的 对象就可以直接进入老年代，无需达到MaxTenuringThreshold中要求的年龄。五、在Minor GC触发时，会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间，如果大 于，改为直接进行一次Full GC，如果小于则查看HandlePromotionFailure设置看看是否允许担保失败，如果 允许，那仍然进行Minor GC，如果不允许，则也要改为进行一次Full GC。

#java 多线程

1.	ExecutorService exec = Executors.newCachedThreadPool();[或Executors.newFixedThreadPool(5)]
	exec.excute(new XXX());
	exec.shutdown();
2.	getPriority()来读取现有线程的优先级，setPriority()设置优先级。setDaenon(true)设置为后台线程，在所有非后台线程结束后，main结束，并且终止后台线程。

3.	long和double变量使用volatile关键字，就可以是其变为原子操作。

4.	wait必须要进行异常捕获。调用wait和notify对象必须采用当前锁调用，即必须采用synchronize中对象。

#spring 和spring mvc相关

1.	理解控制反转（IoC）和依赖注入（DI）[两者含义相同]，aop。spring 通过反射实现DI

2.	Bean工厂和Applicationcontexts有什么区别：
Applicationcontexts提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的bean发布事件。另外，在容器或容器内的对象上执行的那些不得不由bean工厂以程序化方式处理的操作，可以在Applicationcontexts中以声明的方式处理。Applicationcontexts实现了MessageSource接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。collection

3.	一个springbean包含什么

4.	springbean的作用域（5种）

5.	自动装配：5种方式，局限性。

6.	EJB与java bean 的区别。

7.	EJB的几种类型：会话（Session）bean，实体（Entity）bean,消息驱动（Message Driven）bean。会话bean又分为有状态和无状态两种。实体bean分为Bean管理的持续性（BMP）和容器管理的持续性（CMP）两种。

8.	@Require，@Autowired @Qualifier注解

9.	spring支持的事物管理：编程式事务管理（编程的方法处理事务），申明式事务管理（使用注解和xml配置来管理事务）

10.	aop的各种概念

11.	前端控制器DispatcherServlet

12.	sevlet接口，GenericServlet，HttpServlet。sevlet是线程不安全的，ServletContext，HttpSession是线程不安全的，ServletRequest是线程安全的。

#其他

1.	分布式系统负载均衡策略：http://www.open-open.com/lib/view/open1446377378148.html
	轮询，随机，最小相应时间，最小并发数，哈希。

2.	